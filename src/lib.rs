//! Provides functionality to get `n` items from a `&mut [T]`.
//!
//! This library can provide significant performance increase compared to sorting the whole list
//! when `n` is relatively small.
//!
//! ```text
//! N = 100, LEN = 1_000_000, RANGE = 1_000_000:
//! test max           ... bench:   5,907,759 ns/iter (+/- 191,096)
//! test max_unstable  ... bench:   5,792,875 ns/iter (+/- 106,412)
//! test sort          ... bench:  67,507,274 ns/iter (+/- 958,881)
//! test sort_unstable ... bench:  35,584,123 ns/iter (+/- 1,157,209)
//! ```

#![cfg_attr(not(feature = "use_std"), no_std)]
#![doc(html_root_url = "https://docs.rs/out/0.5.2")]
#![deny(
    bad_style,
    bare_trait_objects,
    missing_debug_implementations,
    missing_docs,
    unused_import_braces,
    unused_qualifications
)]

#[cfg(not(feature = "use_std"))]
use core::cmp::Ordering;
#[cfg(not(feature = "use_std"))]
use core::mem;
#[cfg(not(feature = "use_std"))]
use core::slice;
#[cfg(feature = "use_std")]
use std::cmp::Ordering;
#[cfg(feature = "use_std")]
use std::mem;
#[cfg(feature = "use_std")]
use std::slice;

/// Get the `n` largest items.
///
/// # Examples
/// ```
/// let mut v = [-5, 4, 1, -3, 2];
/// let max = out::max(&mut v, 3);
/// assert_eq!(max, [1, 2, 4]);
/// ```
#[inline]
#[cfg(feature = "use_std")]
pub fn max<T: Ord>(v: &mut [T], n: usize) -> &mut [T] {
    max_by(v, n, |a, b| a.cmp(b))
}

/// Get the `n` largest items.
///
/// # Examples
/// ```
/// let mut v = [-5, 4, 1, -3, 2];
/// let max = out::max_unstable(&mut v, 3);
/// assert_eq!(max, [1, 2, 4]);
/// ```
#[inline]
pub fn max_unstable<T: Ord>(v: &mut [T], n: usize) -> &mut [T] {
    max_unstable_by(v, n, |a, b| a.cmp(b))
}

/// Get the `n` largest items.
///
/// # Examples
/// ```
/// let mut v = [-5, 4, 1, -3, 2];
/// let min = out::max_by(&mut v, 3, |a, b| b.cmp(a));
/// assert_eq!(min, [1, -3, -5]);
/// ```
#[inline]
#[cfg(feature = "use_std")]
pub fn max_by<T>(v: &mut [T], mut n: usize, mut f: impl FnMut(&T, &T) -> Ordering) -> &mut [T] {
    if n == 0 {
        return &mut [];
    }
    let (mut max, v) = v.split_at_mut(n);
    max.sort_by(&mut f);
    n -= 1;
    for i in 0..v.len() {
        if f(&v[i], &max[0]) != Ordering::Greater {
            continue;
        } else if f(&v[i], &max[n / 2]) == Ordering::Greater {
            v.swap(i, 0);
            mem::swap(&mut max[n], &mut v[0]);
            let mut j = n;
            if j != 0 {
                while j != 0 && f(&max[j], &max[j - 1]) != Ordering::Greater {
                    max.swap(j, j - 1);
                    j -= 1;
                }
                unsafe {
                    let len = max.len();
                    let ptr = max.as_mut_ptr();
                    max = slice::from_raw_parts_mut(ptr.add(1), len);
                }
            }
        } else {
            mem::swap(&mut v[i], &mut max[0]);
            let mut j = 0;
            while j < n && f(&max[j], &max[j + 1]) == Ordering::Greater {
                max.swap(j, j + 1);
                j += 1;
            }
        }
    }
    max
}

/// Get the `n` largest items.
///
/// # Examples
/// ```
/// let mut v = [-5, 4, 1, -3, 2];
/// let min = out::max_unstable_by(&mut v, 3, |a, b| b.cmp(a));
/// assert_eq!(min, [1, -3, -5]);
/// ```
#[inline]
pub fn max_unstable_by<T>(
    v: &mut [T],
    mut n: usize,
    mut f: impl FnMut(&T, &T) -> Ordering,
) -> &mut [T] {
    if n == 0 {
        return &mut [];
    }
    let (mut max, v) = v.split_at_mut(n);
    max.sort_unstable_by(&mut f);
    n -= 1;
    for i in 0..v.len() {
        if f(&v[i], &max[0]) != Ordering::Greater {
            continue;
        } else if f(&v[i], &max[n / 2]) == Ordering::Greater {
            v.swap(i, 0);
            mem::swap(&mut max[n], &mut v[0]);
            let mut j = n;
            if j != 0 {
                while j != 0 && f(&max[j], &max[j - 1]) == Ordering::Less {
                    max.swap(j, j - 1);
                    j -= 1;
                }
                unsafe {
                    let len = max.len();
                    let ptr = max.as_mut_ptr();
                    max = slice::from_raw_parts_mut(ptr.add(1), len);
                }
            }
        } else {
            mem::swap(&mut v[i], &mut max[0]);
            let mut j = 0;
            while j < n && f(&max[j], &max[j + 1]) == Ordering::Greater {
                max.swap(j, j + 1);
                j += 1;
            }
        }
    }
    max
}

/// Get the `n` largest items decided by a key generated by `f`.
///
/// # Examples
/// ```
/// let mut v = [-5_i32, 4, 1, -3, 2];
/// let max = out::max_by_key(&mut v, 3, |a| a.abs());
/// assert_eq!(max, [-3, 4, -5]);
/// ```
#[inline]
#[cfg(feature = "use_std")]
pub fn max_by_key<T, K: Ord>(v: &mut [T], n: usize, mut f: impl FnMut(&T) -> K) -> &mut [T] {
    max_by(v, n, |a, b| f(a).cmp(&f(b)))
}

/// Get the `n` largest items decided by a key generated by `f`.
///
/// # Examples
/// ```
/// let mut v = [-5_i32, 4, 1, -3, 2];
/// let max = out::max_unstable_by_key(&mut v, 3, |a| a.abs());
/// assert_eq!(max, [-3, 4, -5]);
/// ```
#[inline]
pub fn max_unstable_by_key<T, K: Ord>(
    v: &mut [T],
    n: usize,
    mut f: impl FnMut(&T) -> K,
) -> &mut [T] {
    max_unstable_by(v, n, |a, b| f(a).cmp(&f(b)))
}
